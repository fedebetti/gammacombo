#include <ParameterCache.h>

#include <algorithm>
#include <format>
#include <iostream>
#include <string>
#include <vector>

#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>

#include <RooArgList.h>
#include <RooRealVar.h>

#include <TDatime.h>

using namespace std;
using namespace Utils;

namespace {
  auto msgBase = [](const std::string& prefix, const std::string& msg) {
    auto msgOut = Utils::replaceAll(msg, "\n", "\n" + std::string(prefix.size(), ' '));
    std::cout << prefix << msgOut << endl;
  };
}

///
/// Constructor.
///
/// \param arg - command line options
///
ParameterCache::ParameterCache(OptParser* arg) {
  assert(arg);
  m_arg = arg;
}

void ParameterCache::printFitResultToOutStream(ofstream& out, RooSlimFitResult* slimFitRes) const {

  out << "### FCN: " << slimFitRes->minNll() << ", EDM: " << slimFitRes->edm() << endl;
  out << "### COV quality: " << slimFitRes->covQual() << ", status: " << slimFitRes->status()
      << ", confirmed: " << (slimFitRes->isConfirmed() ? "yes" : "no") << endl;
  RooArgList argList = slimFitRes->floatParsFinal();
  argList.add(slimFitRes->constPars());
  argList.sort();
  for (const auto argAbs : argList) {
    const auto arg = static_cast<RooRealVar*>(argAbs);
    if (TString(arg->GetName()).Contains("obs")) continue;
    out << Form("%-25s", arg->GetName()) << " " << Form("%12.6f", arg->getVal()) << " "
        << Form("%12.6f", arg->getErrorLo()) << " " << Form("%12.6f", arg->getErrorHi()) << endl;
  }
}

void ParameterCache::cacheParameters(MethodAbsScan* scanner, TString fileName) {

  auto info = [](const std::string& msg) { msgBase("ParameterCache::cacheParameters() : ", msg); };
  auto error = [](const std::string& msg) { msgBase("ParameterCache::cacheParameters() : ERROR : ", msg); };

  // cache default solutions
  if (m_arg->debug) info(std::format("saving parameters to: {:s}", std::string(fileName)));

  TDatime d;
  ofstream outfile;
  outfile.open(fileName);
  outfile << "##### auto-generated by ParameterCache #######\n"
          << "##### printed on " << d.AsString() << " ######\n"
          << std::format("{:25s} {:>12s} {:>12s} {:>12s}", "# ParameterName", "value", "errLow", "errHigh") << endl;

  int totalCachedPoints = 0;
  auto&& solutions = scanner->getSolutions();

  for (const auto& sol : solutions) {
    outfile << std::format("\n----- SOLUTION {:d} -----\n", totalCachedPoints);
    printFitResultToOutStream(outfile, sol.get());
    totalCachedPoints++;
  }
  if (m_arg->debug) info(std::format("Cached {:d} solutions", solutions.size()));

  // cache also any specifically requested points
  //
  // 1D
  if (m_arg->savenuisances1d.size() > 0) {
    vector<double>& points = m_arg->savenuisances1d;
    for (auto const& point : points) {

      int iBin = scanner->getHCL()->FindBin(point);
      RooSlimFitResult* r = scanner->curveResults[iBin - 1];
      if (!r) {
        error("No fit result at this scan point!");
        return;
      }
      outfile << std::format("\n----- SOLUTION {:d} (--sn at {:s} = {:10.5f}) -----", totalCachedPoints,
                             std::string(scanner->getScanVar1Name()), point)
              << endl;
      printFitResultToOutStream(outfile, r);
      totalCachedPoints++;
    }
    if (m_arg->debug) info(std::format("Cached {:d} further points", totalCachedPoints - solutions.size()));
  }
  // 2D
  if (m_arg->savenuisances2dx.size() > 0) {
    vector<double>& pointsx = m_arg->savenuisances2dx;
    vector<double>& pointsy = m_arg->savenuisances2dy;

    if (pointsx.size() != pointsy.size()) {
      error("Vectors for savenuisances2dx(y) have different size");
      return;
    }

    for (int i = 0; i < pointsx.size(); i++) {
      int xBin = scanner->getHCL2d()->GetXaxis()->FindBin(pointsx[i]);
      int yBin = scanner->getHCL2d()->GetYaxis()->FindBin(pointsy[i]);
      if (xBin < 1 || xBin > scanner->getNPoints2dx() || yBin < 1 || yBin > scanner->getNPoints2dy()) {
        error("Specified point is out of scan range.");
        continue;
      }

      auto r = scanner->curveResults2d[xBin - 1][yBin - 1];
      if (!r) {
        error("No fit result at this scan point!");
        return;
      }
      outfile << std::format("\n----- SOLUTION {:d} (not glob min just min at {:s} = {:f} , {:s} = {:f} -----",
                             totalCachedPoints, std::string(scanner->getScanVar1Name()), pointsx[i],
                             std::string(scanner->getScanVar2Name()), pointsy[i])
              << endl;
      printFitResultToOutStream(outfile, r);
      totalCachedPoints++;
    }
    if (m_arg->debug) info(std::format("Cached {:d} further points", totalCachedPoints - solutions.size()));
  }
  outfile.close();
}

///
/// Load starting values from a file.
///
/// \param fileName - Load the parameters from a file with this name.
/// \return - true, if a file was loaded
///
bool ParameterCache::loadPoints(TString fileName) {

  bool successfullyLoaded = false;
  startingValues.clear();

  ifstream infile(fileName.Data());
  if (infile) {  // file exists
    if (m_arg->debug) cout << "ParameterCache::loadPoints() -- loading parameters from file " << fileName << endl;
    string line;
    if (infile.is_open()) {
      int nSolutions = 0;
      while (getline(infile, line)) {
        if (line.empty() || boost::starts_with(line, "#"))
          continue;                                   // Skip blank lines and comments
        else if (boost::starts_with(line, "----")) {  // solution here
          nSolutions++;
          startingValues.push_back(map<TString, double>());
        } else {
          vector<string> els;
          boost::split(els, line, boost::is_any_of(" "), boost::token_compress_on);
          TString name = els[0];
          auto val = boost::lexical_cast<double>(els[1]);
          startingValues[nSolutions - 1].insert(make_pair(name, val));
        }
      }
    }
    m_parametersLoaded = true;
    successfullyLoaded = true;
    if (m_arg->debug) printPoint();
  } else {
    cout << "ParameterCache::loadPoints() : ERROR : file not found: " << fileName << endl;
  }
  return successfullyLoaded;
}

void ParameterCache::printPoint() const {

  cout << "ParameterCache::printPoint() -- There are " << startingValues.size() << " solutions with values: " << endl;

  for (unsigned int i = 0; i < startingValues.size(); i++) {
    cout << "SOLUTION " << i << endl;
    for (auto const& [key, val] : startingValues[i]) {
      cout << Form("%-25s", key.Data()) << " " << Form("%12.6f", val) << endl;
    }
  }
}

int ParameterCache::getNPoints() const { return startingValues.size(); }

vector<TString> ParameterCache::getFixedNames(vector<FixPar> fixPar) const {
  vector<TString> names;
  for (auto fp : fixPar) { names.push_back(fp.name); }
  return names;
}

void ParameterCache::setPoint(MethodAbsScan* scanner, int i) { setPoint(scanner->getCombiner(), i); }

void ParameterCache::setPoint(Combiner* cmb, int i) {
  auto error = [](const std::string& msg) {
    msgBase("ParameterCache::setPoint() : ERROR : ", msg + ". Exit");
    exit(1);
  };

  if (!m_parametersLoaded) error("Can't set starting point as no starting values have been loaded");
  if (i >= getNPoints()) error(std::format("Parameter point number {:d} not found in file", i + 1));
  vector<TString> fixNames = getFixedNames(cmb->getConstVars());

  RooWorkspace* w = cmb->getWorkspace();
  if (m_arg->debug) cout << "ParameterCache::setPoint() : Setting parameter values for point " << i + 1 << endl;

  for (auto const& [name, val] : startingValues[i]) {
    if (std::ranges::find(fixNames, name) != fixNames.end()) {
      if (m_arg->debug)
        cout << "\tLeft " << Form("%-15s", name.Data()) << " = " << Form("%12.6f", w->var(name)->getVal())
             << " constant" << endl;
      continue;
    }
    if (w->var(name)) {
      w->var(name)->setVal(val);
      if (m_arg->debug)
        cout << "\tSet  " << Form("%-15s", name.Data()) << " = " << Form("%12.6f", w->var(name)->getVal()) << endl;
    }
  }
}
